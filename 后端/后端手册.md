# 后端手册

## 分页实现

* 前端基于`element`封装的分页组件 [pagination]
* 后端采用基于`mybatis`的轻量级分页插件[pageHelper](https://github.com/pagehelper/Mybatis-PageHelper)

### 前端调用实现

1、前端定义分页流程

```javascript
// 一般在查询参数中定义分页变量
queryParams: {
  pageNum: 1,
  pageSize: 10
},

// 页面添加分页组件，传入分页变量
<pagination
  v-show="total>0"
  :total="total"
  :page.sync="queryParams.pageNum"
  :limit.sync="queryParams.pageSize"
  @pagination="getList"
/>

// 调用后台方法，传入参数 获取结果
listUser(this.queryParams).then(response => {
    this.userList = response.rows;
    this.total = response.total;
  }
);
```

### 后台逻辑实现

```java
    /**
     * 获取用户列表
     */
    @PreAuthorize("@ss.hasPermi('system:user:list')")
    @GetMapping("/list")
    public TableDataInfo list(SysUser user) {
        setPage();// 此方法配合前端完成分页参数的传递
        PageInfo<SysUser> sysUserPageInfo = userService.selectUserPage(user);
        return getDataTable(sysUserPageInfo);
    }
```

```java
    /**
     * 根据条件分页查询用户列表
     *
     * @param user 用户信息
     * @return 用户信息集合信息
     */
    @Override
    @DataScope(deptAlias = "d", userAlias = "u")
    public PageInfo<SysUser> selectUserPage(SysUser user) {
        PageUtils.startPage(); // 此方法自己获取参数完成自动分页
        return new PageInfo<>(userMapper.selectUserList(user));
    }
```

>注意
>
>如果改为其他数据库需修改配置`application.yml`文件中的属性`helperDialect=你的数据库`

## 导入导出

在实际开发中经常需要使用导入导出功能来加快数据的操作。在项目中可以使用注解来完成此项功能。 在需要被导入导出的实体类属性添加`@Excel`注解，目前支持参数如下：

### 注解参数说明

| 参数                  | 类型     | 默认值                        | 描述                                                  |
| --------------------- | -------- | ----------------------------- | ----------------------------------------------------- |
| sort                  | int      | Integer.MAX_VALUE             | 导出时在excel中排序，值越小越靠前                     |
| name                  | String   | 空                            | 导出到Excel中的名字                                   |
| dateFormat            | String   | 空                            | 日期格式, 如: yyyy-MM-dd                              |
| dictType              | String   | 空                            | 如果是字典类型，请设置字典的type值 (如: sys_user_sex) |
| readConverterExp      | String   | 空                            | 读取内容转表达式 (如: 0=男,1=女,2=未知)               |
| separator             | String   | ,                             | 分隔符，读取字符串组内容                              |
| scale                 | int      | -1                            | BigDecimal 精度 默认:-1(默认不开启BigDecimal格式化)   |
| roundingMode          | int      | BigDecimal.ROUND_HALF_EVEN    | BigDecimal 舍入规则 默认:BigDecimal.ROUND_HALF_EVEN   |
| celltype              | Enum     | Type.STRING                   | 导出类型（0数字 1字符串 2图片）                       |
| height                | String   | 14                            | 导出时在excel中每个列的高度 单位为字符                |
| width                 | String   | 16                            | 导出时在excel中每个列的宽 单位为字符                  |
| suffix                | String   | 空                            | 文字后缀,如% 90 变成90%                               |
| defaultValue          | String   | 空                            | 当值为空时,字段的默认值                               |
| prompt                | String   | 空                            | 提示信息                                              |
| combo                 | String   | Null                          | 设置只能选择不能输入的列内容                          |
| headerBackgroundColor | Enum     | IndexedColors.GREY_50_PERCENT | 导出列头背景色IndexedColors.XXXX                      |
| headerColor           | Enum     | IndexedColors.WHITE           | 导出列头字体颜色IndexedColors.XXXX                    |
| backgroundColor       | Enum     | IndexedColors.WHITE           | 导出单元格背景色IndexedColors.XXXX                    |
| color                 | Enum     | IndexedColors.BLACK           | 导出单元格字体颜色IndexedColors.XXXX                  |
| targetAttr            | String   | 空                            | 另一个类中的属性名称,支持多级获取,以小数点隔开        |
| isStatistics          | boolean  | false                         | 是否自动统计数据,在最后追加一行统计数据总和           |
| type                  | Enum     | Type.ALL                      | 字段类型（0：导出导入；1：仅导出；2：仅导入）         |
| align                 | Enum     | HorizontalAlignment.CENTER    | 导出对齐方式HorizontalAlignment.XXXX                  |
| handler               | Class    | ExcelHandlerAdapter.class     | 自定义数据处理器                                      |
| args                  | String[] | {}                            | 自定义数据处理器参数                                  |

### 导出实现流程

1、前端调用方法（参考如下）

```javascript
// 查询参数 queryParams
queryParams: {
  pageNum: 1,
  pageSize: 10,
  userName: undefined
},

// 导出接口exportUser
import { exportUser } from "@/api/system/user";

/** 导出按钮操作 */
handleExport() {
  const queryParams = this.queryParams;
  this.$confirm('是否确认导出所有用户数据项?', "警告", {
	  confirmButtonText: "确定",
	  cancelButtonText: "取消",
	  type: "warning"
	}).then(function() {
	  return exportUser(queryParams);
	}).then(response => {
	  this.download(response.msg);
	}).catch(function() {});
}
```

2、添加导出按钮事件

```html
<el-button
  type="warning"
  icon="el-icon-download"
  size="mini"
  @click="handleExport"
>导出</el-button>
```

3、在实体变量上添加@Excel注解

```java
@Excel(name = "用户序号", prompt = "用户编号")
private Long userId;

@Excel(name = "用户名称")
private String userName;
	
@Excel(name = "用户性别", readConverterExp = "0=男,1=女,2=未知")
private String sex;

@Excel(name = "用户头像", cellType = ColumnType.IMAGE)
private String avatar;

@Excel(name = "帐号状态", dictType = "sys_normal_disable")
private String status;

@Excel(name = "最后登陆时间", width = 30, dateFormat = "yyyy-MM-dd HH:mm:ss")
private Date loginDate;
```

4、在Controller添加导出方法

```java
@Log(title = "用户管理", businessType = BusinessType.EXPORT)
@PreAuthorize("@ss.hasPermi('system:user:export')")
@GetMapping("/export")
public AjaxResult export(SysUser user)
{
	List<SysUser> list = userService.selectUserList(user);
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	return util.exportExcel(list, "用户数据");
}
```

### 导入实现流程

1、前端调用方法（参考如下）

```javascript
import { getToken } from "@/utils/auth";

// 用户导入参数
upload: {
  // 是否显示弹出层（用户导入）
  open: false,
  // 弹出层标题（用户导入）
  title: "",
  // 是否禁用上传
  isUploading: false,
  // 是否更新已经存在的用户数据
  updateSupport: 0,
  // 设置上传的请求头部
  headers: { Authorization: "Bearer " + getToken() },
  // 上传的地址
  url: process.env.VUE_APP_BASE_API + "/system/user/importData"
},

// 导入模板接口importTemplate
import { importTemplate } from "@/api/system/user";

/** 导入按钮操作 */
handleImport() {
  this.upload.title = "用户导入";
  this.upload.open = true;
},
/** 下载模板操作 */
importTemplate() {
  importTemplate().then(response => {
	this.download(response.msg);
  });
},
// 文件上传中处理
handleFileUploadProgress(event, file, fileList) {
  this.upload.isUploading = true;
},
// 文件上传成功处理
handleFileSuccess(response, file, fileList) {
  this.upload.open = false;
  this.upload.isUploading = false;
  this.$refs.upload.clearFiles();
  this.$alert(response.msg, "导入结果", { dangerouslyUseHTMLString: true });
  this.getList();
},
// 提交上传文件
submitFileForm() {
  this.$refs.upload.submit();
}
```

2、添加导入按钮事件

```html
<el-button
  type="info"
  icon="el-icon-upload2"
  size="mini"
  @click="handleImport"
>导入</el-button>
```

3、添加导入前端代码

```html
<!-- 用户导入对话框 -->
<el-dialog :title="upload.title" :visible.sync="upload.open" width="400px">
  <el-upload
	ref="upload"
	:limit="1"
	accept=".xlsx, .xls"
	:headers="upload.headers"
	:action="upload.url + '?updateSupport=' + upload.updateSupport"
	:disabled="upload.isUploading"
	:on-progress="handleFileUploadProgress"
	:on-success="handleFileSuccess"
	:auto-upload="false"
	drag
  >
	<i class="el-icon-upload"></i>
	<div class="el-upload__text">
	  将文件拖到此处，或
	  <em>点击上传</em>
	</div>
	<div class="el-upload__tip" slot="tip">
	  <el-checkbox v-model="upload.updateSupport" />是否更新已经存在的用户数据
	  <el-link type="info" style="font-size:12px" @click="importTemplate">下载模板</el-link>
	</div>
	<div class="el-upload__tip" style="color:red" slot="tip">提示：仅允许导入“xls”或“xlsx”格式文件！</div>
  </el-upload>
  <div slot="footer" class="dialog-footer">
	<el-button type="primary" @click="submitFileForm">确 定</el-button>
	<el-button @click="upload.open = false">取 消</el-button>
  </div>
</el-dialog>
```

4、在实体变量上添加@Excel注解，默认为导出导入，也可以单独设置仅导入Type.IMPORT

```java
@Excel(name = "用户序号")
private Long id;

@Excel(name = "部门编号", type = Type.IMPORT)
private Long deptId;

@Excel(name = "用户名称")
private String userName;

/** 导出部门多个对象 */
@Excels({
	@Excel(name = "部门名称", targetAttr = "deptName", type = Type.EXPORT),
	@Excel(name = "部门负责人", targetAttr = "leader", type = Type.EXPORT)
})
private SysDept dept;

/** 导出部门单个对象 */
@Excel(name = "部门名称", targetAttr = "deptName", type = Type.EXPORT)
private SysDept dept;
```

5、在Controller添加导入方法，updateSupport属性为是否存在则覆盖（可选）

```java
@Log(title = "用户管理", businessType = BusinessType.IMPORT)
@PostMapping("/importData")
public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception
{
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	List<SysUser> userList = util.importExcel(file.getInputStream());
	LoginUser loginUser = tokenService.getLoginUser(ServletUtils.getRequest());
	String operName = loginUser.getUsername();
	String message = userService.importUser(userList, updateSupport, operName);
	return AjaxResult.success(message);
}

@GetMapping("/importTemplate")
public AjaxResult importTemplate()
{
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	return util.importTemplateExcel("用户数据");
}
```

>提示
>
>也可以直接到main运行此方法测试。
>
>```java
>InputStream is = new FileInputStream(new File("D:\\test.xlsx"));
>ExcelUtil<Entity> util = new ExcelUtil<Entity>(Entity.class);
>List<Entity> userList = util.importExcel(is);
>```

### 自定义标题信息

有时候我们希望导出表格包含标题信息，我们可以这样做。

**导出用户管理表格新增标题（用户列表）**

```java
public AjaxResult export(SysUser user)
{
	List<SysUser> list = userService.selectUserList(user);
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	return util.exportExcel(list, "用户数据", "用户列表");
}
```

**导入表格包含标题处理方式，其中`1`表示标题占用行数，根据实际情况填写。**

```java
public AjaxResult importData(MultipartFile file, boolean updateSupport) throws Exception
{
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	List<SysUser> userList = util.importExcel(file.getInputStream(), 1);
	String operName = SecurityUtils.getUsername();
	String message = userService.importUser(userList, updateSupport, operName);
	return AjaxResult.success(message);
}
```

### 自定义数据处理器

有时候我们希望数据展现为一个特殊的格式，或者需要对数据进行其它处理。`Excel`注解提供了自定义数据处理器以满足各种业务场景。而实现一个数据处理器也是非常简单的。如下：

1、在实体类用`Excel`注解`handler`属性指定自定义的数据处理器

```java
public class User extends BaseEntity
{
    @Excel(name = "用户名称", handler = MyDataHandler.class, args = { "aaa", "bbb" })
    private String userName;
}
```

2、编写数据处理器`MyDataHandler`继承`ExcelHandlerAdapter`，返回值为处理后的值。

```java
public class MyDataHandler implements ExcelHandlerAdapter
{
    @Override
    public Object format(Object value, String[] args)
    {
        // value 为单元格数据值
		// args 为excel注解args参数组
		return value;
    }
}
```

### 自定义隐藏属性列

有时候我们希望对列信息根据业务去动态显示，那么我们可以进行如下处理。

示例：对用户进行条件判断，符合条件则隐藏属性。导出的文件则不会显示此列信息。

```java
@PostMapping("/export")
public void export(HttpServletResponse response, SysUser user)
{
	List<SysUser> list = userService.selectUserList(user);
	ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
	if (条件A) {
	  // 不显示用户ID（单个）
	  util.hideColumn("userId");
	} else if (条件B) {
	  // 不显示用户名称、用户手机（多个）
	  util.hideColumn("userId", "phonenumber");
	}
	util.exportExcel(response, list, "用户数据");
}
```

### 导出对象的子列表

有时候对象里面还包含集合列表，例如用户管理包含多个角色需要导出，那么我们可以进行如下处理。

**SysUser.java**

```java
public class SysUser
{
    @Excel(name = "用户编号", cellType = ColumnType.NUMERIC, width = 20, needMerge = true)
    private String userId;

    @Excel(name = "用户名称", width = 20, needMerge = true)
    private String userName;

    @Excel(name = "邮箱", width = 20, needMerge = true)
    private String email;

    @Excel(name = "角色")
    private List<SysRole> roles;

    public String getUserId()
    {
        return userId;
    }

    public void setUserId(String userId)
    {
        this.userId = userId;
    }

    public String getUserName()
    {
        return userName;
    }

    public void setUserName(String userName)
    {
        this.userName = userName;
    }

    public String getEmail()
    {
        return email;
    }

    public void setEmail(String email)
    {
        this.email = email;
    }

    public List<SysRole> getRoles()
    {
        return roles;
    }

    public void setRoles(List<SysRole> roles)
    {
        this.roles = roles;
    }
}
```

**SysRole.java**

```java
public class SysRole
{
    @Excel(name = "角色编号", cellType = ColumnType.NUMERIC)
    private String roleId;

    @Excel(name = "角色名称")
    private String roleName;

    @Excel(name = "角色字符")
    private String roleKey;

    public String getRoleId()
    {
        return roleId;
    }

    public void setRoleId(String roleId)
    {
        this.roleId = roleId;
    }

    public String getRoleName()
    {
        return roleName;
    }

    public void setRoleName(String roleName)
    {
        this.roleName = roleName;
    }

    public String getRoleKey()
    {
        return roleKey;
    }

    public void setRoleKey(String roleKey)
    {
        this.roleKey = roleKey;
    }

}
```

**测试验证**

```java
public class Test
{
    public static void main(String[] args) throws IOException
    {
        List<SysUser> userList = new ArrayList<SysUser>();

        SysUser user1 = new SysUser();
        List<SysRole> roles1 = new ArrayList<SysRole>();

        SysRole role1 = new SysRole();
        role1.setRoleId("1");
        role1.setRoleName("超级管理员");
        role1.setRoleKey("admin_key");

        SysRole role2 = new SysRole();
        role2.setRoleId("2");
        role2.setRoleName("普通角色");
        role2.setRoleKey("common_key");
        
        SysRole role3 = new SysRole();
        role3.setRoleId("3");
        role3.setRoleName("测试角色");
        role3.setRoleKey("test_key");
        
        SysRole role4 = new SysRole();
        role4.setRoleId("4");
        role4.setRoleName("查询角色");
        role4.setRoleKey("query_key");

        roles1.add(role1);
        roles1.add(role2);
        roles1.add(role3);
        roles1.add(role4);

        user1.setUserId("1");
        user1.setUserName("admin");
        user1.setEmail("ry@qq.com");
        user1.setRoles(roles1);

        userList.add(user1);
        
        
        SysUser user2 = new SysUser();
        List<SysRole> roles2 = new ArrayList<SysRole>();

        SysRole role21 = new SysRole();
        role21.setRoleId("4");
        role21.setRoleName("研发角色");
        role21.setRoleKey("yanfa_key");

        SysRole role22 = new SysRole();
        role22.setRoleId("5");
        role22.setRoleName("销售角色");
        role22.setRoleKey("xiaoshou_key");

        roles2.add(role21);
        roles2.add(role22);

        user2.setUserId("2");
        user2.setUserName("ry");
        user2.setEmail("admin@qq.com");
        user2.setRoles(roles2);
        
        userList.add(user2);
        
        SysUser user3 = new SysUser();
        List<SysRole> roles3 = new ArrayList<SysRole>();

        SysRole role31 = new SysRole();
        role31.setRoleId("4");
        role31.setRoleName("张三角色");
        role31.setRoleKey("zs_key");

        SysRole role32 = new SysRole();
        role32.setRoleId("5");
        role32.setRoleName("李四角色");
        role32.setRoleKey("ls_key");

        roles3.add(role31);
        roles3.add(role32);

        user3.setUserId("3");
        user3.setUserName("test");
        user3.setEmail("test@qq.com");
        user3.setRoles(roles3);
        
        userList.add(user3);

        ExcelUtil<SysUser> util = new ExcelUtil<SysUser>(SysUser.class);
        AjaxResult ajax = util.exportExcel(userList, "用户数据", "用户数据");
        System.out.println(ajax.toString());
    }
}
```

**导出文件结果**

 ![ruoyi-sub-execl](https://oscimg.oschina.net/oscnet/up-6b1853322c0d5472bee27065023bd06841b.png)

## 上传下载

首先创建一张上传文件的表，例如：

```sql
drop table if exists sys_file_info;
create table sys_file_info (
  file_id           int(11)          not null auto_increment       comment '文件id',
  file_name         varchar(50)      default ''                    comment '文件名称',
  file_path         varchar(255)     default ''                    comment '文件路径',
  primary key (file_id)
) engine=innodb auto_increment=1 default charset=utf8 comment = '文件信息表';
```

### 上传实现流程

1、`el-input`修改成`el-upload`

```vue
<el-upload
  ref="upload"
  :limit="1"
  accept=".jpg, .png"
  :action="upload.url"
  :headers="upload.headers"
  :file-list="upload.fileList"
  :on-progress="handleFileUploadProgress"
  :on-success="handleFileSuccess"
  :auto-upload="false">
  <el-button slot="trigger" size="small" type="primary">选取文件</el-button>
  <el-button style="margin-left: 10px;" size="small" type="success" :loading="upload.isUploading" @click="submitUpload">上传到服务器</el-button>
  <div slot="tip" class="el-upload__tip">只能上传jpg/png文件，且不超过500kb</div>
</el-upload>
```

2、引入获取`token`

```javascript
import { getToken } from "@/utils/auth";
```

3、`data`中添加属性

```javascript
// 上传参数
upload: {
  // 是否禁用上传
  isUploading: false,
  // 设置上传的请求头部
  headers: { Authorization: "Bearer " + getToken() },
  // 上传的地址
  url: process.env.VUE_APP_BASE_API + "/common/upload",
  // 上传的文件列表
  fileList: []
},
```

4、新增和修改操作对应处理`fileList`参数

```javascript
handleAdd() {
  ...
  this.upload.fileList = [];
}

handleUpdate(row) {
  ...
  this.upload.fileList = [{ name: this.form.fileName, url: this.form.filePath }];
}
```

5、添加对应事件

```javascript
// 文件提交处理
submitUpload() {
  this.$refs.upload.submit();
},
// 文件上传中处理
handleFileUploadProgress(event, file, fileList) {
  this.upload.isUploading = true;
},
// 文件上传成功处理
handleFileSuccess(response, file, fileList) {
  this.upload.isUploading = false;
  this.form.filePath = response.url;
  this.msgSuccess(response.msg);
}
```

### 下载实现流程

1、添加对应按钮和事件

```vue
<el-button
  size="mini"
  type="text"
  icon="el-icon-edit"
  @click="handleDownload(scope.row)"
>下载</el-button>
```

2、实现文件下载

```javascript
// 文件下载处理
handleDownload(row) {
  var name = row.fileName;
  var url = row.filePath;
  var suffix = url.substring(url.lastIndexOf("."), url.length);
  const a = document.createElement('a')
  a.setAttribute('download', name + suffix)
  a.setAttribute('target', '_blank')
  a.setAttribute('href', url)
  a.click()
}
```

## 权限注解

`Spring Security`提供了`Spring EL`表达式，允许我们在定义接口访问的方法上面添加注解，来控制访问权限。

### 权限方法

`@PreAuthorize`注解用于配置接口要求用户拥有某些权限才可访问，它拥有如下方法

| 方法        | 参数   | 描述                                           |
| ----------- | ------ | ---------------------------------------------- |
| hasPermi    | String | 验证用户是否具备某权限                         |
| lacksPermi  | String | 验证用户是否不具备某权限，与 hasPermi逻辑相反  |
| hasAnyPermi | String | 验证用户是否具有以下任意一个权限               |
| hasRole     | String | 判断用户是否拥有某个角色                       |
| lacksRole   | String | 验证用户是否不具备某角色，与 isRole逻辑相反    |
| hasAnyRoles | String | 验证用户是否具有以下任意一个角色，多个逗号分隔 |

###  使用示例

其中`@ss`代表的是[PermissionService]服务，对每个接口拦截并调用`PermissionService`的对应方法判断接口调用者的权限。

1. 数据权限示例。

```java
// 符合system:user:list权限要求
@PreAuthorize("@ss.hasPermi('system:user:list')")

// 不符合system:user:list权限要求
@PreAuthorize("@ss.lacksPermi('system:user:list')")

// 符合system:user:add或system:user:edit权限要求即可
@PreAuthorize("@ss.hasAnyPermi('system:user:add,system:user:edit')")
```

2. 角色权限示例。

```java
// 属于user角色
@PreAuthorize("@ss.hasRole('user')")

// 不属于user角色
@PreAuthorize("@ss.lacksRole('user')")

// 属于user或者admin之一
@PreAuthorize("@ss.hasAnyRoles('user,admin')")
```

>权限提示
>
>超级管理员拥有所有权限，不受权限约束。

### 公开接口

如果有些接口是不需要验证权限可以公开访问的，这个时候就需要我们给接口放行。

使用注解方式，只需要在`Controller`的类或方法上加入`@Anonymous`该注解即可

```java
// @PreAuthorize("@ss.xxxx('....')") 注释或删除掉原有的权限注解
@Anonymous
@GetMapping("/list")
public List<SysXxxx> list(SysXxxx xxxx)
{
    return xxxxList;
}
```

## 事务管理

新建的`Spring Boot`项目中，一般都会引用`spring-boot-starter`或者`spring-boot-starter-web`，而这两个起步依赖中都已经包含了对于`spring-boot-starter-jdbc`或`spring-boot-starter-data-jpa`的依赖。 当我们使用了这两个依赖的时候，框架会自动默认分别注入`DataSourceTransactionManager`或`JpaTransactionManager`。 所以我们不需要任何额外配置就可以用`@Transactional`注解进行事务的使用。

>提示
>
>@Transactional注解只能应用到public可见度的方法上，可以被应用于接口定义和接口方法，方法会覆盖类上面声明的事务。

例如用户新增需要插入用户表、用户与岗位关联表、用户与角色关联表，如果插入成功，那么一起成功，如果中间有一条出现异常，那么回滚之前的所有操作， 这样可以防止出现脏数据，就可以使用事务让它实现回退。
做法非常简单，我们只需要在方法或类添加`@Transactional`注解即可。

```java
@Transactional
public int insertUser(User user)
{
	// 新增用户信息
	int rows = userMapper.insertUser(user);
	// 新增用户岗位关联
	insertUserPost(user);
	// 新增用户与角色管理
	insertUserRole(user);
	return rows;
}
```

- 常见坑点1：遇到检查异常时，事务开启，也无法回滚。 例如下面这段代码，用户依旧增加成功，并没有因为后面遇到检查异常而回滚！！

```java
@Transactional
public int insertUser(User user) throws Exception
{
	// 新增用户信息
	int rows = userMapper.insertUser(user);
	// 新增用户岗位关联
	insertUserPost(user);
	// 新增用户与角色管理
	insertUserRole(user);
	// 模拟抛出SQLException异常
	boolean flag = true;
	if (flag)
	{
		throw new SQLException("发生异常了..");
	}
	return rows;
}
```

原因分析：因为`Spring`的默认的事务规则是遇到运行异常`（RuntimeException）`和程序错误`（Error）`才会回滚。如果想针对检查异常进行事务回滚，可以在`@Transactional`注解里使用 `rollbackFor`属性明确指定异常。
例如下面这样，就可以正常回滚：

```java
@Transactional(rollbackFor = Exception.class)
public int insertUser(User user) throws Exception
{
	// 新增用户信息
	int rows = userMapper.insertUser(user);
	// 新增用户岗位关联
	insertUserPost(user);
	// 新增用户与角色管理
	insertUserRole(user);
	// 模拟抛出SQLException异常
	boolean flag = true;
	if (flag)
	{
		throw new SQLException("发生异常了..");
	}
	return rows;
}
```

- 常见坑点2： 在业务层捕捉异常后，发现事务不生效。 这是许多新手都会犯的一个错误，在业务层手工捕捉并处理了异常，你都把异常“吃”掉了，`Spring`自然不知道这里有错，更不会主动去回滚数据。
  例如：下面这段代码直接导致用户新增的事务回滚没有生效。

```java
@Transactional
public int insertUser(User user) throws Exception
{
	// 新增用户信息
	int rows = userMapper.insertUser(user);
	// 新增用户岗位关联
	insertUserPost(user);
	// 新增用户与角色管理
	insertUserRole(user);
	// 模拟抛出SQLException异常
	boolean flag = true;
	if (flag)
	{
		try
		{
			// 谨慎：尽量不要在业务层捕捉异常并处理
			throw new SQLException("发生异常了..");
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}
	return rows;
}
```

推荐做法：在业务层统一抛出异常，然后在控制层统一处理。

```java
@Transactional
public int insertUser(User user) throws Exception
{
	// 新增用户信息
	int rows = userMapper.insertUser(user);
	// 新增用户岗位关联
	insertUserPost(user);
	// 新增用户与角色管理
	insertUserRole(user);
	// 模拟抛出SQLException异常
	boolean flag = true;
	if (flag)
	{
		throw new RuntimeException("发生异常了..");
	}
	return rows;
}
```

`Transactional`注解的常用属性表：

| 属性          | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| propagation   | 事务的传播行为，默认值为 REQUIRED。                          |
| isolation     | 事务的隔离度，默认值采用 DEFAULT                             |
| timeout       | 事务的超时时间，默认值为-1，不超时。如果设置了超时时间(单位秒)，那么如果超过该时间限制了但事务还没有完成，则自动回滚事务。 |
| read-only     | 指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。 |
| rollbackFor   | 用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。{xxx1.class, xxx2.class,……} |
| noRollbackFor | 抛出 no-rollback-for 指定的异常类型，不回滚事务。{xxx1.class, xxx2.class,……} |
| ....          |                                                              |

>提示
>
>事务的传播机制是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。 即:在执行一个@Transactinal注解标注的方法时，开启了事务；当该方法还在执行中时，另一个人也触发了该方法；那么此时怎么算事务呢，这时就可以通过事务的传播机制来指定处理方式。

`TransactionDefinition`传播行为的常量：

| 常量                                            | 含义                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| TransactionDefinition.PROPAGATION_REQUIRED      | 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。 |
| TransactionDefinition.PROPAGATION_REQUIRES_NEW  | 创建一个新的事务，如果当前存在事务，则把当前事务挂起。       |
| TransactionDefinition.PROPAGATION_SUPPORTS      | 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 |
| TransactionDefinition.PROPAGATION_NOT_SUPPORTED | 以非事务方式运行，如果当前存在事务，则把当前事务挂起。       |
| TransactionDefinition.PROPAGATION_NEVER         | 以非事务方式运行，如果当前存在事务，则抛出异常。             |
| TransactionDefinition.PROPAGATION_MANDATORY     | 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。 |
| TransactionDefinition.PROPAGATION_NESTED        | 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。 |

## 异常处理

通常一个`web`框架中，有大量需要处理的异常。比如业务异常，权限不足等等。前端通过弹出提示信息的方式告诉用户出了什么错误。 通常情况下我们用`try.....catch....`对异常进行捕捉处理，但是在实际项目中对业务模块进行异常捕捉，会造成代码重复和繁杂， 我们希望代码中只有业务相关的操作，所有的异常我们单独设立一个类来处理它。全局异常就是对框架所有异常进行统一管理。 我们在可能发生异常的方法里`throw`抛给控制器。然后由全局异常处理器对异常进行统一处理。 如此，我们的`Controller`中的方法就可以很简洁了。

所谓全局异常处理器就是使用`@ControllerAdvice`注解。示例如下：

1、统一返回实体定义

```java
package org.tl.common.domain;

import cn.hutool.core.util.StrUtil;
import com.alibaba.fastjson2.JSON;
import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.Data;
import org.tl.common.constant.HttpStatus;
import org.tl.common.exception.ExceptionCodeEnum;
import org.tl.common.exception.ResultCode;

import java.io.Serializable;

/**
 * 统一返回实体
 */
@Data
@JsonInclude(JsonInclude.Include.ALWAYS)
public class Result<T> implements Serializable {

    private static final long serialVersionUID = 42L;
    /**
     * 是否成功
     */
    private Boolean success;
    /**
     * 返回code代码
     */
    private Integer returnCode;
    /**
     * 返回信息提示
     */
    private String message;

    /**
     * 报错缘由
     */
    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String cause;
    /**
     * 返回数据
     */
    private T data;

    public static <T> Result<T> build(Boolean success, int returnCode, String message) {
        return new Result<>(success, returnCode, message);

    }

    public static <T> Result<T> build(Boolean success, int returnCode, T data, String message) {
        return new Result<>(success, returnCode, data, message);

    }

    public static <T> Result<T> ok(String message) {
        return new Result<>(message);
    }

    public static <T> Result<T> data(T data) {
        return new Result<>(data, "成功");
    }

    public static <T> Result<T> ok(T data, String message) {
        return new Result<>(data, message);
    }

    public static <T> Result<T> failed(ExceptionCodeEnum statusCode, String message) {
        return new Result<>(false, statusCode.returnCode(),
                StrUtil.isEmpty(message) ? statusCode.message() : message);
    }

    public static <T> Result<T> failed(ExceptionCodeEnum statusCode) {
        return new Result<>(false, statusCode.returnCode(), statusCode.message());
    }

    public static <T> Result<T> failed(String message) {
        return new Result<>(false, HttpStatus.ERROR, message);
    }

    public static <T> Result<T> failed() {
        return new Result<>(false, HttpStatus.ERROR, "操作失败");
    }

    public static <T> Result<T> failed(T data, String message) {
        return new Result<>(false, HttpStatus.ERROR, data, message);
    }

    public static <T> Result<T> ok() {
        return new Result<>((String) null);
    }

    public static <T> Result<T> noLogin() {
        return new Result<>(false, 530, null, "未登录");
    }

    public static <T> Result<T> failLogin() {
        return new Result<>(true, 401, null, "登录失败");
    }

    public Result() {

    }

    public Result(Boolean success, int returnCode, String message) {
        this.success = success;
        this.returnCode = returnCode;
        this.message = message;
    }

    public Result(Boolean success, int returnCode, T data, String message) {
        this.success = success;
        this.returnCode = returnCode;
        this.data = data;
        this.message = message;
    }

    public Result(String message) {
        this.success = true;
        this.returnCode = HttpStatus.SUCCESS;
        this.message = message;
    }

    public Result(T data, String message) {
        this.success = true;
        this.returnCode = HttpStatus.SUCCESS;
        this.data = data;
        this.message = message;
    }

    public Result(ResultCode resultCode) {
        this.success = resultCode.success();
        this.returnCode = resultCode.returnCode();
        this.message = resultCode.message();
    }

    @Override
    public String toString() {
        return JSON.toJSONString(this);
    }
}
```

2、定义错误码

```java
package org.tl.common.exception;

/**
 * @Date: 2021/3/11 11:05
 * @Description:状态码
 */
public enum ExceptionCodeEnum implements ResultCode {
    /**
     * 状态码
     */
    STATUS_CODE_SUCCESS(true, 200, "请求成功！"),
    STATUS_CODE_PARAMETERS_ILLEGAL(false, 203, "参数非法！"),
    STATUS_CODE_PARAMETERS_ONLY(false, 207, "节点ID存在重复,请重新输入"),
    STATUS_CODE_MUST_PARAMETERS(false, 204, "缺少必填参数"),
    STATUS_CODE_DELETED(false, 410, "已删除！"),
    STATUS_CODE_DEL_ERROR(false, 411, "删除错误"),
    STATUS_CODE_INTERNAL_ERROR(false, 500, "服务内部出现未知异常！"),
    STATUS_BAN(false, 206, "禁止撤回"),
    STATUS_CODE_NO_LOGIN(false, 530, "用户未登录！"),
    STATUS_CODE_PASSWORD_ERROR(false, 531, "用户名或密码错误！"),
    STATUS_CODE_USER_PASSWORD_RETRY_LIMIT_EXCEED(false, 534, "用户输入账号密码超过错误最大次数"),
    STATUS_CODE_USER_JCAPTCHA_EXPIRE(false, 535, "验证码过期"),
    STATUS_CODE_USER_JCAPTCHA_ERROR(false, 536, "验证码错误"),
    STATUS_CODE_UNAUTHORIZED(false, 401, "未授权"),
    STATUS_CODE_PERMISSION_DENIED(false, 403, "用户没有权限！"),
    STATUS_CODE_REQUEST_NOT_SUPPORT(false, 405, "请求的方式不支持！"),
    STATUS_SCHEDULER_ERROR(false, 550, "定时任务错误！"),

    STATUS_FILE_NOT_FOUND_ERROR(false, 450, "系统找不到指定的路径！"),
    STATUS_FILE_IO_ERROR(false, 451, "文件IO错误！"),
    STATUS_SQL_CONSTRAINT_ERROR(false, 460, "SQL唯一约束错误！"),

    STATUS_SQL_BINDING_ERROR(false, 461, "SQL方法绑定错误！"),

    STATUS_SQL_INTEGRITY_ERROR(false, 462, "SQL异常！"),

    STATUS_SQL_SYNTAX_ERROR(false, 462, "SQL语法错误！"),

    STATUS_FILE_ERROR(false, 600, "文件操作出错！"),

    STATUS_FILE_EMPTY(false, 601, "文件为空！"),

    NETWORK_EXCEPTION(false, 701, "服务器网络异常"),
    TIMEOUT_EXCEPTION(false, 702, "服务器调用超时"),
    SERIALIZATION_EXCEPTION(false, 703, "服务器序列化异常"),
    METHOD_NOT_FOUND(false, 704, "服务器未找到调用的方法"),
    NO_INVOKER_AVAILABLE_AFTER_FILTER(false, 705, "service服务不可用");


    /**
     * 操作是否成功
     */
    final boolean success;
    /**
     * 操作代码
     */
    final int returnCode;
    /**
     * 提示信息
     */
    final String message;

    ExceptionCodeEnum(boolean success,
                      Integer returnCode,
                      String message) {
        this.success = success;
        this.returnCode = returnCode;
        this.message = message;
    }

    public boolean success() {
        return success;
    }

    public Integer returnCode() {
        return returnCode;
    }

    public String message() {
        return message;
    }
}

```



3、全局异常处理器

```java
package org.tl.framework.web.exception;

import cn.hutool.core.io.IORuntimeException;
import cn.hutool.core.util.StrUtil;
import cn.hutool.extra.spring.SpringUtil;
import lombok.extern.slf4j.Slf4j;
import org.apache.dubbo.common.utils.StringUtils;
import org.apache.dubbo.rpc.RpcException;
import org.apache.dubbo.rpc.StatusRpcException;
import org.apache.dubbo.rpc.TriRpcStatus;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.validation.BindException;
import org.springframework.validation.ObjectError;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.tl.common.domain.Result;
import org.tl.common.exception.CustomException;
import org.tl.common.exception.ExceptionCodeEnum;
import org.tl.common.exception.ResultCode;

import java.io.FileNotFoundException;
import java.nio.file.AccessDeniedException;
import java.sql.SQLIntegrityConstraintViolationException;
import java.util.concurrent.ConcurrentHashMap;

import static org.tl.common.constant.Constants.ENV_PROD;


/**
 * 全局异常处理器
 *
 * @date 2022/07/08
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    private static ConcurrentHashMap<String, ResultCode> exceptionsMap = new ConcurrentHashMap<>(32);


    //初始化builder中不可预知异常类的对应错误信息
    static {
        exceptionsMap.put(HttpMessageNotReadableException.class.getName(), ExceptionCodeEnum.STATUS_CODE_PARAMETERS_ILLEGAL);
        exceptionsMap.put(HttpRequestMethodNotSupportedException.class.getName(), ExceptionCodeEnum.STATUS_CODE_REQUEST_NOT_SUPPORT);
        exceptionsMap.put(AccessDeniedException.class.getName(), ExceptionCodeEnum.STATUS_CODE_PERMISSION_DENIED);
        exceptionsMap.put(FileNotFoundException.class.getName(), ExceptionCodeEnum.STATUS_FILE_NOT_FOUND_ERROR);
        exceptionsMap.put(IORuntimeException.class.getName(), ExceptionCodeEnum.STATUS_FILE_IO_ERROR);
        exceptionsMap.put(SQLIntegrityConstraintViolationException.class.getName(), ExceptionCodeEnum.STATUS_SQL_CONSTRAINT_ERROR);
        exceptionsMap.put("org.springframework.dao.DataIntegrityViolationException", ExceptionCodeEnum.STATUS_SQL_CONSTRAINT_ERROR);
        exceptionsMap.put("org.apache.ibatis.binding.BindingException", ExceptionCodeEnum.STATUS_SQL_BINDING_ERROR);
        exceptionsMap.put("java.sql.SQLSyntaxErrorException", ExceptionCodeEnum.STATUS_SQL_SYNTAX_ERROR);
        exceptionsMap.put("org.springframework.jdbc.BadSqlGrammarException", ExceptionCodeEnum.STATUS_SQL_SYNTAX_ERROR);
    }

    @ExceptionHandler(Exception.class)
    public Result<Object> handlerException(Exception exception) {
        log.warn("错误：", exception);
        String className = exception.getClass().getName();
        return getResult(className, exception);
    }

    /**
     * 得到结果
     *
     * @param className 类名
     * @return {@link Result}<{@link Object}>
     */
    private Result<Object> getResult(String className, Exception exception) {
        ResultCode resultCode = getResultCode(className);
        Result<Object> result;
        //找到了对应的错误信息
        if (null != resultCode) {
            result = new Result<>(resultCode);
        } else {
            result = new Result<>(ExceptionCodeEnum.STATUS_CODE_INTERNAL_ERROR);
        }
        addCauseInfo(result, exception.getMessage());
        //返回结果响应体
        return result;
    }


    /**
     * 得到结果代码
     *
     * @param exceptionClassName 异常类名字
     * @return {@link ResultCode}
     */
    private ResultCode getResultCode(String exceptionClassName) {
        return exceptionsMap.get(exceptionClassName);
    }

    @ExceptionHandler(value = BindException.class)
    public Result<Object> bindExceptionHandler(BindException ex) {
        // 拼接错误
        StringBuilder detailMessage = new StringBuilder();
        for (ObjectError objectError : ex.getAllErrors()) {
            // 使用 ; 分隔多个错误
            if (detailMessage.length() > 0) {
                detailMessage.append(";");
            }
            // 拼接内容到其中
            detailMessage.append(objectError.getDefaultMessage());
        }
        // 包装 Result 结果
        return new Result<>(false, 400, detailMessage.toString());
    }

    @ExceptionHandler(value = MissingServletRequestParameterException.class)
    public Result<Object> bindExceptionHandler(MissingServletRequestParameterException ex) {
        return new Result<>(false, 400, ex.getParameterName() + "不能为空");
    }
    @ExceptionHandler(value = MethodArgumentNotValidException.class)
    public Result<Object> bindExceptionHandler(MethodArgumentNotValidException ex) {
        // 拼接错误
        StringBuilder detailMessage = new StringBuilder();

        for (ObjectError objectError : ex.getBindingResult().getAllErrors()) {
            // 使用 ; 分隔多个错误
            if (detailMessage.length() > 0) {
                detailMessage.append(";");
            }
            // 拼接内容到其中
            detailMessage.append(objectError.getDefaultMessage());
        }
        // 包装 Result 结果
        return new Result<>(false, 400, detailMessage.toString());
    }


    @ExceptionHandler(CustomException.class)
    public Result<Object> handlerCustomException(CustomException e) {
        ResultCode resultCode = e.getResultCode();
        String message = e.getMsg();
        if (StringUtils.isNotEmpty(message)) {
            return new Result<>(false, resultCode.returnCode(), message);
        }
        return new Result<>(resultCode);
    }
    /**
     * 添加附加报错信息
     *
     * @param result  结果
     * @param message 消息
     */
    private void addCauseInfo(Result<Object> result, String message) {
        if (StrUtil.isBlank(message)) {
            return;
        }
        result.setCause(StrUtil.subBetween(message, "###", "###"));
    }

    @ExceptionHandler(RpcException.class)
    public Result<Object> handleRpcException(RpcException e) {
        String activeProfile = SpringUtil.getActiveProfile();
        if (!ENV_PROD.equals(activeProfile)) {
            log.warn("RpcException", e);
            log.warn("code:{},msg:{}", e.getCode(), e.getMessage());
        }

        if (e.getCode() == RpcException.UNKNOWN_EXCEPTION || e.getCode() == RpcException.BIZ_EXCEPTION) {
            Throwable cause = e.getCause();
            if (cause != null) {
                Throwable throwable = cause.getCause();
                if (throwable instanceof StatusRpcException) {
                    StatusRpcException statusRpcException = (StatusRpcException) throwable;
                    TriRpcStatus status = statusRpcException.getStatus();
                    String message = status.toMessageWithoutCause();
                    if (StrUtil.isNotEmpty(message)) {
                        String clazz = message.split(":")[1];
                        if (StrUtil.isNotEmpty(clazz)) {
                            return getResult(clazz, e);
                        }
                    }
                }
            }
        }
        Result<Object> result = handleRpcInnerException(e);
        addCauseInfo(result, e.getMessage());
        return result;


    }

    private Result<Object> handleRpcInnerException(RpcException e) {
        int code = e.getCode();
        switch (code) {
            case RpcException.NETWORK_EXCEPTION:
                return Result.failed(ExceptionCodeEnum.NETWORK_EXCEPTION);
            case RpcException.TIMEOUT_EXCEPTION:
                return Result.failed(ExceptionCodeEnum.TIMEOUT_EXCEPTION);
            case RpcException.SERIALIZATION_EXCEPTION:
                return Result.failed(ExceptionCodeEnum.SERIALIZATION_EXCEPTION);
            case RpcException.METHOD_NOT_FOUND:
                return Result.failed(ExceptionCodeEnum.METHOD_NOT_FOUND);
            case RpcException.NO_INVOKER_AVAILABLE_AFTER_FILTER:
                return Result.failed(ExceptionCodeEnum.NO_INVOKER_AVAILABLE_AFTER_FILTER);
            default:
                return new Result<>(ExceptionCodeEnum.STATUS_CODE_INTERNAL_ERROR);
        }
    }
}
```

4、测试访问请求

```java
@RestController
public class SysIndexController 
{
    /**
     * 首页方法
     */
    @GetMapping("/index")
    public String index(ModelMap mmap)
    {
        /**
         * 模拟用户未登录，抛出业务逻辑异常
         */
        LoginUserDTO user = SecurityUtils.getLoginUser();
        if (StringUtils.isNull(user))
		{
            throw new CustomException(ExceptionCodeEnum.STATUS_CODE_NO_LOGIN, "用户未登录，无法访问请求。");
        }
		mmap.put("user", user);
        return "index";
    }
}
```

## 参数验证

`spring boot`中可以用`@Validated`来校验数据，如果数据异常则会统一抛出异常，方便异常中心统一处理。

### 注解参数说明

| 注解名称                   | 功能                                                         |
| -------------------------- | ------------------------------------------------------------ |
| @Xss                       | 检查该字段是否存在跨站脚本工具                               |
| @Null                      | 检查该字段为空                                               |
| @NotNull                   | 不能为null                                                   |
| @NotBlank                  | 不能为空，常用于检查空字符串                                 |
| @NotEmpty                  | 不能为空，多用于检测list是否size是0                          |
| @Max                       | 该字段的值只能小于或等于该值                                 |
| @Min                       | 该字段的值只能大于或等于该值                                 |
| @Past                      | 检查该字段的日期是在过去                                     |
| @Future                    | 检查该字段的日期是否是属于将来的日期                         |
| @Email                     | 检查是否是一个有效的email地址                                |
| @Pattern(regex=,flag=)     | 被注释的元素必须符合指定的正则表达式                         |
| @Range(min=,max=,message=) | 被注释的元素必须在合适的范围内                               |
| @Size(min=, max=)          | 检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等 |
| @Length(min=,max=)         | 检查所属的字段的长度是否在min和max之间,只能用于字符串        |
| @AssertTrue                | 用于boolean字段，该字段只能为true                            |
| @AssertFalse               | 该字段的值只能为false                                        |

### 数据校验使用

1、基础使用 因为`spring boot`已经引入了基础包，所以直接使用就可以了。首先在`controller`上声明`@Validated`需要对数据进行校验。

```java
public AjaxResult add(@Validated @RequestBody SysUser user)
{
    .....
}
```

2、然后在对应字段`Get方法`加上参数校验注解，如果不符合验证要求，则会以`message`的信息为准，返回给前端。

```java
@Size(min = 0, max = 30, message = "用户昵称长度不能超过30个字符")
public String getNickName()
{
	return nickName;
}

@NotBlank(message = "用户账号不能为空")
@Size(min = 0, max = 30, message = "用户账号长度不能超过30个字符")
public String getUserName()
{
	return userName;
}

@Email(message = "邮箱格式不正确")
@Size(min = 0, max = 50, message = "邮箱长度不能超过50个字符")
public String getEmail()
{
	return email;
}

@Size(min = 0, max = 11, message = "手机号码长度不能超过11个字符")
public String getPhonenumber()
{
	return phonenumber;
}
```

>也可以直接放在字段上面声明。
>
>```java
>@Size(min = 0, max = 30, message = "用户昵称长度不能超过30个字符")
>private String nickName;
>```

### 自定义注解校验

使用原生的`@Validated`进行参数校验时，都是特定的注解去校验（例如字段长度、大小、不为空等），我们也可以用自定义的注解去进行校验，例如项目中的`@Xss`注解。

1、新增`Xss`注解，设置自定义校验器`XssValidator.class`

```java
/**
 * 自定义xss校验注解
 * 
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(value = { ElementType.METHOD, ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.PARAMETER })
@Constraint(validatedBy = { XssValidator.class })
public @interface Xss
{
    String message()

    default "不允许任何脚本运行";

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

2、自定义`Xss`校验器，实现`ConstraintValidator`接口。

```java
/**
 * 自定义xss校验注解实现
 * 
 */
public class XssValidator implements ConstraintValidator<Xss, String>
{
    private final String HTML_PATTERN = "<(\\S*?)[^>]*>.*?|<.*? />";

    @Override
    public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext)
    {
        return !containsHtml(value);
    }

    public boolean containsHtml(String value)
    {
        Pattern pattern = Pattern.compile(HTML_PATTERN);
        Matcher matcher = pattern.matcher(value);
        return matcher.matches();
    }
}
```

3、实体类使用自定义的`@Xss`注解

```java
@Xss(message = "登录账号不能包含脚本字符")
@NotBlank(message = "登录账号不能为空")
@Size(min = 0, max = 30, message = "登录账号长度不能超过30个字符")
public String getLoginName()
{
	return loginName;
}
```

此时在去保存会进行验证，如果不符合规则的字符（例如`<script>alert(1);</script>`）会提示`登录账号不能包含脚本字符`，代表限制成功。

>如果是在方法里面校验整个实体，参考示例。
>
>```java
>@Autowired
>protected Validator validator;
>
>public void importUser(SysUser user)
>{
>    BeanValidators.validateWithException(validator, user);
>}
>```

### 自定义分组校验

有时候我们为了在使用实体类的情况下更好的区分出新增、修改和其他操作验证的不同，可以通过`groups`属性设置。使用方式如下

**新增类接口，用于标识出不同的操作类型**

```java
public interface Add
{
}

public interface Edit
{
}
```

**Controller.java**

```java
// 新增
public AjaxResult addSave(@Validated(Add.class) @RequestBody Xxxx xxxx)
{
    return success(xxxx);
}

// 编辑
public AjaxResult editSave(@Validated(Edit.class) @RequestBody Xxxx xxxx)
{
    return success(xxxx);
}
```

**Model.java**

```java
// 仅在新增时验证
@NotNull(message = "不能为空", groups = {Add.class})
private String xxxx;

// 在新增和修改时验证
@NotBlank(message = "不能为空", groups = {Add.class, Edit.class})
private String xxxx;
```

>提示
>
>如果你有更多操作类型，也可以自定义类统一管理，使用方式就变成了`Type.Add`、`Type.Edit`、`Type.Xxxx`等。
>
>```java
>package com.eva.core.constants;
>
>/**
> * 操作类型
> */
>public interface Type 
>{
>    interface Add {}
>
>    interface Edit {}
>
>    interface Xxxx {}
>}
>```

## 系统日志

在实际开发中，对于某些关键业务，我们通常需要记录该操作的内容，一个操作调一次记录方法，每次还得去收集参数等等，会造成大量代码重复。 我们希望代码中只有业务相关的操作，在项目中使用注解来完成此项功能。

在需要被记录日志的`controller`方法上添加`@Log`注解，使用方法如下：

```java
@Log(title = "用户管理", businessType = BusinessType.INSERT)
public AjaxResult addSave(...)
{
    return success(...);
}
```

###  注解参数说明

| 参数               | 类型         | 默认值 | 描述                                                         |
| ------------------ | ------------ | ------ | ------------------------------------------------------------ |
| title              | String       | 空     | 操作模块                                                     |
| businessType       | BusinessType | OTHER  | 操作功能（`OTHER`其他、`INSERT`新增、`UPDATE`修改、`DELETE`删除、`GRANT`授权、`EXPORT`导出、`IMPORT`导入、`FORCE`强退、`GENCODE`生成代码、`CLEAN`清空数据） |
| operatorType       | OperatorType | MANAGE | 操作人类别（`OTHER`其他、`MANAGE`后台用户、`MOBILE`手机端用户） |
| isSaveRequestData  | boolean      | true   | 是否保存请求的参数                                           |
| isSaveResponseData | boolean      | true   | 是否保存响应的参数                                           |

### 自定义操作功能

1、在`BusinessType`中新增业务操作类型如:

```java
/**
 * 测试
 */
TEST,
```

2、在`sys_dict_data`字典数据表中初始化操作业务类型

```sql
insert into sys_dict_data values(25, 10, '测试',     '10', 'sys_oper_type',       '',   'primary', 'N', '0', 'admin', '2018-03-16 11-33-00', 'ry', '2018-03-16 11-33-00', '测试操作');
```

3、在`Controller`中使用注解

```java
@Log(title = "测试标题", businessType = BusinessType.TEST)
public AjaxResult test(...)
{
    return success(...);
}
```

操作日志记录逻辑实现代码[LogAspect.java]
登录系统（系统管理-操作日志）可以查询操作日志列表和详细信息。

##  数据权限

在实际开发中，需要设置用户只能查看哪些部门的数据，这种情况一般称为数据权限。
例如对于销售，财务的数据，它们是非常敏感的，因此要求对数据权限进行控制， 对于基于集团性的应用系统而言，就更多需要控制好各自公司的数据了。如设置只能看本公司、或者本部门的数据，对于特殊的领导，可能需要跨部门的数据， 因此程序不能硬编码那个领导该访问哪些数据，需要进行后台的权限和数据权限的控制。

>提示
>
>默认系统管理员`admin`拥有所有数据权限`（userId=1）`，默认角色拥有所有数据权限（如不需要数据权限不用设置数据权限操作）

### 注解参数说明

| 参数      | 类型   | 默认值 | 描述         |
| --------- | ------ | ------ | ------------ |
| deptAlias | String | 空     | 部门表的别名 |
| userAlias | String | 空     | 用户表的别名 |

###  数据权限使用

1、在（系统管理-角色管理）设置需要数据权限的角色 目前支持以下几种权限

- 全部数据权限
- 自定数据权限
- 部门数据权限
- 部门及以下数据权限
- 仅本人数据权限

2、在需要数据权限控制方法上添加`@DataScope`注解，其中`d`和`u`用来表示表的别名

**部门数据权限注解**

```java
@DataScope(deptAlias = "d")
public List<...> select(...)
{
    return mapper.select(...);
}
```

**部门及用户权限注解**

```java
@DataScope(deptAlias = "d", userAlias = "u")
public List<...> select(...)
{
    return mapper.select(...);
}
```

3、在`mybatis`查询底部标签添加数据范围过滤

```xml
<select id="select" parameterType="..." resultMap="...Result">
    <include refid="select...Vo"/>
    <!-- 数据范围过滤 -->
    ${params.dataScope}
</select>
```

例如：用户管理（未过滤数据权限的情况）：

```sql
select u.user_id, u.dept_id, u.login_name, u.user_name, u.email
	, u.phonenumber, u.password, u.sex, u.avatar, u.salt
	, u.status, u.del_flag, u.login_ip, u.login_date, u.create_by
	, u.create_time, u.remark, d.dept_name
from sys_user u
	left join sys_dept d on u.dept_id = d.dept_id
where u.del_flag = '0'
```

例如：用户管理（已过滤数据权限的情况）

```sql
select u.user_id, u.dept_id, u.login_name, u.user_name, u.email
	, u.phonenumber, u.password, u.sex, u.avatar, u.salt
	, u.status, u.del_flag, u.login_ip, u.login_date, u.create_by
	, u.create_time, u.remark, d.dept_name
from sys_user u
	left join sys_dept d on u.dept_id = d.dept_id
where u.del_flag = '0'
	and u.dept_id in (
		select dept_id
		from sys_role_dept
		where role_id = 2
	)
```

结果很明显，我们多了如下语句。通过角色部门表`（sys_role_dept）`完成了数据权限过滤

```sql
and u.dept_id in (
	select dept_id
	from sys_role_dept
	where role_id = 2
)
```

逻辑实现代码 `org.tl.framework.aspectj.DataScopeAspect`

>提示
>
>仅实体继承`BaseEntity`才会进行处理，`SQL`语句会存放到`BaseEntity`对象中的`params`属性中，然后在`xml`中通过`${params.dataScope}`获取拼接后的语句。

## 防重复提交

在接口方法上添加`@RepeatSubmit`注解即可，注解参数说明：

| 参数     | 类型   | 默认值                     | 描述                                 |
| -------- | ------ | -------------------------- | ------------------------------------ |
| interval | int    | 5000                       | 间隔时间(ms)，小于此时间视为重复提交 |
| message  | String | 不允许重复提交，请稍后再试 | 提示消息                             |

**示例1：采用默认参数**

```java
@RepeatSubmit
public AjaxResult addSave(...)
{
    return success(...);
}
```

**示例2：指定防重复时间和错误消息**

```java
@RepeatSubmit(interval = 1000, message = "请求过于频繁")
public AjaxResult addSave(...)
{
    return success(...);
}
```